{"version":3,"sources":["utils/EditorUtils.js","utils/CommentState.js","components/CommentRow.js","components/NodePopover.js","utils/EditorCommentUtils.js","components/CommentThreadPopover.js","components/CommentsSidebar.js","components/LinkEditor.js","hooks/useAddCommentThreadCallback.js","components/Toolbar.js","hooks/useImageUploadHandler.js","components/Image.js","components/Link.js","components/CommentedText.js","components/StyledText.js","hooks/useEditorConfig.js","components/Editor.js","hooks/useSelection.js","utils/ExampleDocument.js","App.js","reportWebVitals.js","index.js"],"names":["getActiveStyles","editor","Set","Object","keys","Editor","marks","getTextBlockStyle","selection","topLevelBlockNodesInSelection","nodes","at","mode","match","n","isBlock","blockType","nodeEntry","next","done","node","value","type","toggleStyle","style","has","removeMark","addMark","hasActiveLinkAtSelection","isLinkNodeAtSelection","above","createLinkForRange","range","linkText","linkURL","isInsertion","Transforms","insertNodes","url","children","text","undefined","wrapNodes","split","commentThreadsState","atomFamily","key","default","commentThreadIDsState","atom","activeCommentThreadIDAtom","CommentRow","comment","author","creationTime","className","format","NodePopover","header","editorOffsets","isBodyFullWidth","onClickOutside","popoverRef","useRef","useEditor","useEffect","editorEl","current","ReactEditor","toDOMNode","getBoundingClientRect","nodeX","x","nodeHeight","height","nodeY","y","display","top","left","scrollIntoView","onMouseDown","useCallback","event","contains","target","document","addEventListener","removeEventListener","Card","ref","Header","Body","padding","COMMENT_THREAD_PREFIX","shouldAllowNewCommentThreadAtSelection","Range","isCollapsed","textNodeIterator","nextTextNodeEntry","textNodeEntriesInSelection","push","length","some","getCommentThreadsOnTextNode","size","getMarkForCommentThreadID","threadID","getCommentThreadIDFromMark","mark","replace","isCommentThreadIDMark","mayBeMark","indexOf","textNode","filter","map","updateCommentThreadLengthMap","commentThreads","nodeIterator","nextNodeEntry","nextNode","commentThreadsOnNextNode","intersection","i","set","get","setCommentThreadData","a","textNodesWithComments","Text","isText","textNodeEntry","forEach","add","Array","from","id","comments","Date","status","CommentThreadPopover","selectionForNode","getFirstTextNodeAtSelection","setActiveCommentThreadID","useSetRecoilState","useRecoilStateLoadable","threadDataLoadable","useState","commentText","setCommentText","onClick","threadData","onToggleStatus","currentStatus","contents","onCommentTextChange","slateDOMNode","hasAttribute","closest","slateNode","toSlateNode","hasThreadData","state","shouldAllowStatusChange","index","Form","Control","bsPrefix","placeholder","onChange","Button","variant","disabled","CommentsSidebar","allCommentThreadIDs","useRecoilValue","Row","Col","CommentThread","useRecoilState","activeCommentThreadID","shouldShowReplies","setShouldShowReplies","onBtnClick","textNodesWithThread","allTextNodePaths","sort","p1","p2","Path","compare","select","anchor","point","edge","focus","firstComment","otherComments","body","classNames","showConnector","LinkEditor","selectionForLink","path","setLinkURL","onLinkURLChange","onApply","setNodes","isUrl","useAddCommentThreadCallback","useRecoilCallback","ids","PARAGRAPH_STYLES","CHARACTER_STYLES","Toolbar","previousSelection","addCommentThread","onBlockTypeChange","targetType","changeTo","toggleBlockType","onImageSelected","preventDefault","files","file","fileName","name","formData","FormData","append","uuidv4","caption","isUploading","axios","post","headers","then","response","setTimeout","newImageEntry","catch","error","useImageUploadHandler","onInsertComment","newCommentThreadID","insertCommentThread","DropdownButton","title","getLabelForBlockStyle","onSelect","Dropdown","Item","eventKey","ToolBarStyleButton","icon","getIconForButton","ToolBarButton","isActive","label","unwrapNodes","Element","isElement","toggleLinkAtSelection","as","htmlFor","accept","props","otherProps","active","Error","Image","attributes","element","isEditingCaption","setEditingCaption","setCaption","selected","useSelected","focused","useFocused","applyCaptionChange","captionInput","imageNodeEntry","onCaptionChange","onKeyDown","isHotkey","onToggleCaptionEditMode","wasEditing","contentEditable","Spinner","animation","src","String","alt","autoFocus","defaultValue","onBlur","Link","href","CommentedText","commentThreadsAsArray","newActiveCommentThreadID","commentThreadsLengthByID","Map","slateEditor","nodePath","previous","minLength","Number","POSITIVE_INFINITY","getSmallestCommentThreadAtTextNode","StyledText","leaf","bold","code","italic","underline","renderElement","content-editable","renderLeaf","KeyBindings","editorRef","useMemo","withReact","createEditor","isVoid","includes","isInline","useEditorConfig","setSelection","setSelectionOptimized","newSelection","areEqual","useSelection","onChangeLocal","doc","parent","currentNode","currentNodePath","edges","start","cursorPoint","startPointOfLastCharacter","before","unit","lastCharacter","string","end","startOfTextNode","Point","isBefore","lastWordRange","lastWord","Promise","resolve","identifyLinksInTextIfAny","initializeStateWithAllCommentThreads","fluid","Container","overlappingCommentThreadID","uuid","ExampleDocument","DebugObserver","snapshot","useRecoilSnapshot","console","debug","getNodes_UNSTABLE","isModified","getLoadable","App","updateDocument","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.5329982b.chunk.js","sourcesContent":["import { Editor, Element } from \"slate\";\nimport { Point, Range, Text, Transforms } from \"slate\";\n\nimport isUrl from \"is-url\";\n\nexport function getActiveStyles(editor) {\n  return new Set(Object.keys(Editor.marks(editor) ?? {}));\n}\n\nexport function getTextBlockStyle(editor) {\n  const selection = editor.selection;\n  if (selection == null) {\n    return null;\n  }\n\n  const topLevelBlockNodesInSelection = Editor.nodes(editor, {\n    at: editor.selection,\n    mode: \"highest\",\n    match: (n) => Editor.isBlock(editor, n),\n  });\n\n  let blockType = null;\n  let nodeEntry = topLevelBlockNodesInSelection.next();\n  while (!nodeEntry.done) {\n    const [node] = nodeEntry.value;\n    if (blockType == null) {\n      blockType = node.type;\n    } else if (blockType !== node.type) {\n      return \"multiple\";\n    }\n\n    nodeEntry = topLevelBlockNodesInSelection.next();\n  }\n\n  return blockType !== \"image\" ? blockType : null;\n}\n\nexport function toggleStyle(editor, style) {\n  const activeStyles = getActiveStyles(editor);\n  if (activeStyles.has(style)) {\n    Editor.removeMark(editor, style);\n  } else {\n    Editor.addMark(editor, style, true);\n  }\n}\n\nexport function toggleBlockType(editor, blockType) {\n  const currentBlockType = getTextBlockStyle(editor);\n  const changeTo = currentBlockType === blockType ? \"paragraph\" : blockType;\n  Transforms.setNodes(\n    editor,\n    { type: changeTo },\n    { at: editor.selection, match: (n) => Editor.isBlock(editor, n) }\n  );\n}\n\nexport function hasActiveLinkAtSelection(editor) {\n  return isLinkNodeAtSelection(editor, editor.selection);\n}\n\nexport function toggleLinkAtSelection(editor) {\n  if(editor.selection == null) {\n    return;\n  }\n  \n  if (hasActiveLinkAtSelection(editor)) {\n    Transforms.unwrapNodes(editor, {\n      match: (n) => Element.isElement(n) && n.type === \"link\",\n    });\n  } else {\n    const isSelectionCollapsed =\n      editor.selection == null || Range.isCollapsed(editor.selection);\n    if (isSelectionCollapsed) {\n      createLinkForRange(editor, null, \"link\", \"\", true /*isInsertion*/);\n    } else {\n      createLinkForRange(editor, editor.selection, \"\", \"\");\n    }\n  }\n}\n\nexport function isLinkNodeAtSelection(editor, selection) {\n  if (selection == null) {\n    return false;\n  }\n\n  return (\n    Editor.above(editor, {\n      at: selection,\n      match: (n) => n.type === \"link\",\n    }) != null\n  );\n}\n\nexport function identifyLinksInTextIfAny(editor) {\n  // if selection is not collapsed, we do not proceed with the link detection.\n  if (editor.selection == null || !Range.isCollapsed(editor.selection)) {\n    return;\n  }\n\n  const [node] = Editor.parent(editor, editor.selection);\n  // if we are already inside a link, exit early.\n  if (node.type === \"link\") {\n    return;\n  }\n\n  const [currentNode, currentNodePath] = Editor.node(editor, editor.selection);\n  if (!Text.isText(currentNode)) {\n    return;\n  }\n\n  let [start] = Range.edges(editor.selection);\n  const cursorPoint = start;\n\n  const startPointOfLastCharacter = Editor.before(editor, editor.selection, {\n    unit: \"character\",\n  });\n\n  let lastCharacter = Editor.string(\n    editor,\n    Editor.range(editor, startPointOfLastCharacter, cursorPoint)\n  );\n\n  if (lastCharacter !== \" \") {\n    return;\n  }\n\n  let end = startPointOfLastCharacter;\n  start = Editor.before(editor, end, {\n    unit: \"character\",\n  });\n\n  const startOfTextNode = Editor.point(editor, currentNodePath, {\n    edge: \"start\",\n  });\n\n  lastCharacter = Editor.string(editor, Editor.range(editor, start, end));\n\n  while (lastCharacter !== \" \" && !Point.isBefore(start, startOfTextNode)) {\n    end = start;\n    start = Editor.before(editor, end, { unit: \"character\" });\n    lastCharacter = Editor.string(editor, Editor.range(editor, start, end));\n  }\n\n  const lastWordRange = Editor.range(editor, end, startPointOfLastCharacter);\n  const lastWord = Editor.string(editor, lastWordRange);\n\n  if (isUrl(lastWord)) {\n    Promise.resolve().then(() =>\n      createLinkForRange(editor, lastWordRange, lastWord, lastWord)\n    );\n  }\n}\n\nfunction createLinkForRange(editor, range, linkText, linkURL, isInsertion) {\n  isInsertion\n    ? Transforms.insertNodes(\n        editor,\n        {\n          type: \"link\",\n          url: linkURL,\n          children: [{ text: linkText }],\n        },\n        range != null ? { at: range } : undefined\n      )\n    : Transforms.wrapNodes(\n        editor,\n        { type: \"link\", url: linkURL, children: [{ text: linkText }] },\n        { split: true, at: range }\n      );\n}\n\nexport function getFirstTextNodeAtSelection(editor, selection) {\n  const selectionForNode = selection ?? editor.selection;\n\n  if (selectionForNode == null) {\n    return null;\n  }\n\n  const textNodeEntry = Editor.nodes(editor, {\n    at: selectionForNode,\n    mode: \"lowest\",\n  }).next().value;\n\n  return textNodeEntry != null && Text.isText(textNodeEntry[0])\n    ? textNodeEntry[0]\n    : null;\n}\n","import { atom, atomFamily } from \"recoil\";\n\nimport React from \"react\";\n\nexport const SetActiveCommentThreadIDContext = React.createContext(null);\n\nexport const commentThreadsState = atomFamily({\n  key: \"commentThreads\",\n  default: null,\n});\n\nexport const commentThreadIDsState = atom({\n  key: \"commentThreadIDs\",\n  default: new Set([]),\n});\n\nexport const activeCommentThreadIDAtom = atom({\n  key: \"activeCommentThreadID\",\n  default: null,\n});\n","import { format } from \"date-fns\";\n\nexport default function CommentRow({\n  comment: { author, text, creationTime },\n}) {\n  return (\n    <div className={\"comment-row\"}>\n      <div className=\"comment-author-photo\">\n        <i className=\"bi bi-person-circle comment-author-photo\"></i>\n      </div>\n      <div>\n        <span className=\"comment-author-name\">{author}</span>\n        <span className=\"comment-creation-time\">\n          {format(creationTime, \"eee MM/dd H:mm\")}\n        </span>\n        <div className=\"comment-text\">{text}</div>\n      </div>\n    </div>\n  );\n}\n","import { ReactEditor, useEditor } from \"slate-react\";\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport Card from \"react-bootstrap/Card\";\n\nexport default function NodePopover({\n  header,\n  node,\n  children,\n  editorOffsets,\n  className,\n  isBodyFullWidth,\n  onClickOutside,\n}) {\n  const popoverRef = useRef(null);\n  const editor = useEditor();\n\n  useEffect(() => {\n    const editorEl = popoverRef.current;\n    if (editorEl == null) {\n      return;\n    }\n\n    const domNode = ReactEditor.toDOMNode(editor, node);\n    const {\n      x: nodeX,\n      height: nodeHeight,\n      y: nodeY,\n    } = domNode.getBoundingClientRect();\n\n    editorEl.style.display = \"block\";\n    editorEl.style.top = `${nodeY + nodeHeight - editorOffsets.y}px`;\n    editorEl.style.left = `${nodeX - editorOffsets.x}px`;\n    editorEl.scrollIntoView(false);\n  }, [editor, editorOffsets.x, editorOffsets.y, node]);\n\n  const onMouseDown = useCallback(\n    (event) => {\n      if (\n        popoverRef.current != null &&\n        !popoverRef.current.contains(event.target) &&\n        onClickOutside != null\n      ) {\n        onClickOutside(event);\n      }\n    },\n    [onClickOutside]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"mousedown\", onMouseDown);\n\n    return () => {\n      document.removeEventListener(\"mousedown\", onMouseDown);\n    };\n  }, [onMouseDown]);\n\n  if (editorOffsets == null) {\n    return null;\n  }\n\n  return (\n    <Card ref={popoverRef} className={className}>\n      {header != null ? <Card.Header>{header}</Card.Header> : null}\n      <Card.Body style={isBodyFullWidth ? { padding: 0 } : undefined}>\n        {children}\n      </Card.Body>\n    </Card>\n  );\n}\n","import { Editor, Range, Text } from \"slate\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nconst COMMENT_THREAD_PREFIX = \"commentThread_\";\n\nexport function shouldAllowNewCommentThreadAtSelection(editor, selection) {\n  if (selection == null || Range.isCollapsed(selection)) {\n    return false;\n  }\n\n  const textNodeIterator = Editor.nodes(editor, {\n    at: selection,\n    mode: \"lowest\",\n  });\n\n  let nextTextNodeEntry = textNodeIterator.next().value;\n  const textNodeEntriesInSelection = [];\n  while (nextTextNodeEntry != null) {\n    textNodeEntriesInSelection.push(nextTextNodeEntry);\n    nextTextNodeEntry = textNodeIterator.next().value;\n  }\n\n  if (textNodeEntriesInSelection.length === 0) {\n    return false;\n  }\n\n  // If any text is uncommented on, later on, user could click on that\n  // text to see details of this thread so allow a new comment thread\n  // to be created.\n  return textNodeEntriesInSelection.some(\n    ([textNode]) => getCommentThreadsOnTextNode(textNode).size === 0\n  );\n}\n\nexport function insertCommentThread(editor, addCommentThread) {\n  const threadID = uuidv4();\n  addCommentThread(threadID, {\n    comments: [],\n    creationTime: new Date(),\n    status: \"open\",\n  });\n  Editor.addMark(editor, getMarkForCommentThreadID(threadID), true);\n  return threadID;\n}\n\nexport function getMarkForCommentThreadID(threadID) {\n  return `${COMMENT_THREAD_PREFIX}${threadID}`;\n}\n\nexport function getCommentThreadIDFromMark(mark) {\n  return mark.replace(COMMENT_THREAD_PREFIX, \"\");\n}\n\nexport function isCommentThreadIDMark(mayBeMark) {\n  return mayBeMark.indexOf(COMMENT_THREAD_PREFIX) === 0;\n}\n\nexport function getCommentThreadsOnTextNode(textNode) {\n  if (textNode == null) {\n    debugger;\n  }\n  return new Set(\n    Object.keys(textNode)\n      .filter(isCommentThreadIDMark)\n      .map(getCommentThreadIDFromMark)\n  );\n}\n\nexport function getSmallestCommentThreadAtTextNode(editor, textNode) {\n  const commentThreads = getCommentThreadsOnTextNode(textNode);\n  const commentThreadsAsArray = [...commentThreads];\n\n  let newActiveCommentThreadID = commentThreadsAsArray[0];\n\n  const reverseTextNodeIterator = (slateEditor, nodePath) =>\n    Editor.previous(slateEditor, {\n      at: nodePath,\n      mode: \"lowest\",\n      match: Text.isText,\n    });\n\n  const forwardTextNodeIterator = (slateEditor, nodePath) =>\n    Editor.next(slateEditor, {\n      at: nodePath,\n      mode: \"lowest\",\n      match: Text.isText,\n    });\n\n  if (commentThreads.size > 1) {\n    const commentThreadsLengthByID = new Map(\n      commentThreadsAsArray.map((id) => [id, textNode.text.length])\n    );\n\n    updateCommentThreadLengthMap(\n      editor,\n      commentThreads,\n      reverseTextNodeIterator,\n      commentThreadsLengthByID\n    );\n\n    updateCommentThreadLengthMap(\n      editor,\n      commentThreads,\n      forwardTextNodeIterator,\n      commentThreadsLengthByID\n    );\n\n    let minLength = Number.POSITIVE_INFINITY;\n\n    for (let [threadID, length] of commentThreadsLengthByID) {\n      if (length < minLength) {\n        newActiveCommentThreadID = threadID;\n        minLength = length;\n      }\n    }\n  }\n\n  return newActiveCommentThreadID;\n}\n\nfunction updateCommentThreadLengthMap(\n  editor,\n  commentThreads,\n  nodeIterator,\n  map\n) {\n  let nextNodeEntry = nodeIterator(editor);\n  while (nextNodeEntry != null) {\n    const nextNode = nextNodeEntry[0];\n    const commentThreadsOnNextNode = getCommentThreadsOnTextNode(nextNode);\n    const intersection = [...commentThreadsOnNextNode].filter((x) =>\n      commentThreads.has(x)\n    );\n    // All comment threads we're looking for have already ended.\n    if (intersection.length === 0) {\n      break;\n    }\n\n    for (let i = 0; i < intersection.length; i++) {\n      map.set(intersection[i], map.get(intersection[i]) + nextNode.text.length);\n    }\n\n    nextNodeEntry = nodeIterator(editor, nextNodeEntry[1]);\n  }\n\n  return map;\n}\n\nexport async function initializeStateWithAllCommentThreads(\n  editor,\n  setCommentThreadData\n) {\n  const textNodesWithComments = Editor.nodes(editor, {\n    at: [],\n    mode: \"lowest\",\n    match: (n) => Text.isText(n) && getCommentThreadsOnTextNode(n).size > 0,\n  });\n\n  const commentThreads = new Set();\n\n  let textNodeEntry = textNodesWithComments.next().value;\n  while (textNodeEntry != null) {\n    [...getCommentThreadsOnTextNode(textNodeEntry[0])].forEach((threadID) => {\n      commentThreads.add(threadID);\n    });\n    textNodeEntry = textNodesWithComments.next().value;\n  }\n\n  // Fetch comment threads from server and use the setter to set them here. For the sake\n  // of the article, we just set them to some default so we know the initialization works.\n  Array.from(commentThreads).forEach((id) =>\n    setCommentThreadData(id, {\n      comments: [\n        {\n          author: \"Tej Prakash Prasad\",\n          text: \"Comment Thread Loaded from Server\",\n          creationTime: new Date(),\n        },\n      ],\n      status: \"open\",\n    })\n  );\n}\n","import \"./CommentThreadPopover.css\";\n\nimport { ReactEditor, useEditor } from \"slate-react\";\nimport {\n  activeCommentThreadIDAtom,\n  commentThreadsState,\n} from \"../utils/CommentState\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useRecoilStateLoadable, useSetRecoilState } from \"recoil\";\n\nimport Button from \"react-bootstrap/Button\";\nimport CommentRow from \"./CommentRow\";\nimport Form from \"react-bootstrap/Form\";\nimport NodePopover from \"./NodePopover\";\nimport { Text } from \"slate\";\nimport { getCommentThreadsOnTextNode } from \"../utils/EditorCommentUtils\";\nimport { getFirstTextNodeAtSelection } from \"../utils/EditorUtils\";\n\nexport default function CommentThreadPopover({\n  editorOffsets,\n  selection,\n  threadID,\n}) {\n  const editor = useEditor();\n  const textNode = getFirstTextNodeAtSelection(editor, selection);\n\n  const setActiveCommentThreadID = useSetRecoilState(activeCommentThreadIDAtom);\n\n  const [threadDataLoadable, setCommentThreadData] = useRecoilStateLoadable(\n    commentThreadsState(threadID)\n  );\n\n  const [commentText, setCommentText] = useState(\"\");\n\n  const onClick = useCallback(() => {\n    setCommentThreadData((threadData) => ({\n      ...threadData,\n      comments: [\n        ...threadData.comments,\n        { text: commentText, author: \"Tej Prakash\", creationTime: new Date() },\n      ],\n    }));\n    setCommentText(\"\");\n  }, [commentText, setCommentThreadData]);\n\n  const onToggleStatus = useCallback(() => {\n    const currentStatus = threadDataLoadable.contents.status;\n    setCommentThreadData((threadData) => ({\n      ...threadData,\n      status: currentStatus === \"open\" ? \"resolved\" : \"open\",\n    }));\n  }, [setCommentThreadData, threadDataLoadable.contents.status]);\n\n  const onCommentTextChange = useCallback(\n    (event) => setCommentText(event.target.value),\n    [setCommentText]\n  );\n\n  const onClickOutside = useCallback(\n    (event) => {\n      const slateDOMNode = event.target.hasAttribute(\"data-slate-node\")\n        ? event.target\n        : event.target.closest(`[data-slate-node]`);\n\n      // The click event was somewhere outside the Slate hierarchy\n      if (slateDOMNode == null) {\n        setActiveCommentThreadID(null);\n        return;\n      }\n\n      const slateNode = ReactEditor.toSlateNode(editor, slateDOMNode);\n\n      // Click is on another commented text node => do nothing.\n      if (\n        Text.isText(slateNode) &&\n        getCommentThreadsOnTextNode(slateNode).size > 0\n      ) {\n        return;\n      }\n\n      setActiveCommentThreadID(null);\n    },\n    [editor, setActiveCommentThreadID]\n  );\n\n  useEffect(() => {\n    //inputRef.current?.focus();\n    return () => {\n      setActiveCommentThreadID(null);\n    };\n  }, [setActiveCommentThreadID]);\n\n  const hasThreadData = threadDataLoadable.state === \"hasValue\";\n  const threadData = threadDataLoadable.contents;\n\n  return (\n    <NodePopover\n      editorOffsets={editorOffsets}\n      isBodyFullWidth={true}\n      node={textNode}\n      className={\"comment-thread-popover\"}\n      header={\n        <Header\n          status={threadData.status ?? null}\n          shouldAllowStatusChange={\n            hasThreadData && threadData.comments.length > 0\n          }\n          onToggleStatus={onToggleStatus}\n        />\n      }\n      onClickOutside={onClickOutside}\n    >\n      {hasThreadData ? (\n        <>\n          <div className={\"comment-list\"}>\n            {threadData.comments.map((comment, index) => (\n              <CommentRow key={index} comment={comment} />\n            ))}\n          </div>\n          <div className={\"comment-input-wrapper\"}>\n            <Form.Control\n              bsPrefix={\"comment-input form-control\"}\n              placeholder={\"Type a comment\"}\n              type=\"text\"\n              value={commentText}\n              onChange={onCommentTextChange}\n            />\n            <Button\n              size=\"sm\"\n              variant=\"primary\"\n              disabled={commentText.length === 0}\n              onClick={onClick}\n            >\n              Comment\n            </Button>\n          </div>\n        </>\n      ) : (\n        \"Loading\"\n      )}\n    </NodePopover>\n  );\n}\n\nfunction Header({ onToggleStatus, shouldAllowStatusChange, status }) {\n  return (\n    <div className={\"comment-thread-popover-header\"}>\n      {shouldAllowStatusChange && status != null ? (\n        <Button size=\"sm\" variant=\"primary\" onClick={onToggleStatus}>\n          {status === \"open\" ? \"Resolve\" : \"Re-Open\"}\n        </Button>\n      ) : null}\n    </div>\n  );\n}\n","import \"./CommentSidebar.css\";\n\nimport { Editor, Path, Text, Transforms } from \"slate\";\nimport {\n  activeCommentThreadIDAtom,\n  commentThreadIDsState,\n  commentThreadsState,\n} from \"../utils/CommentState\";\nimport { useCallback, useState } from \"react\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\n\nimport Button from \"react-bootstrap/Button\";\nimport Card from \"react-bootstrap/Card\";\nimport Col from \"react-bootstrap/Col\";\nimport CommentRow from \"./CommentRow\";\nimport Row from \"react-bootstrap/Row\";\nimport classNames from \"classnames\";\nimport { getCommentThreadsOnTextNode } from \"../utils/EditorCommentUtils\";\nimport { useEditor } from \"slate-react\";\n\nexport default function CommentsSidebar() {\n  const allCommentThreadIDs = useRecoilValue(commentThreadIDsState);\n\n  return (\n    <Card className={\"comments-sidebar\"}>\n      <Card.Header>Comments</Card.Header>\n      <Card.Body>\n        {Array.from(allCommentThreadIDs).map((id) => (\n          <Row key={id}>\n            <Col>\n              <CommentThread id={id} />\n            </Col>\n          </Row>\n        ))}\n      </Card.Body>\n    </Card>\n  );\n}\n\nfunction CommentThread({ id }) {\n  const editor = useEditor();\n  const { comments, status } = useRecoilValue(commentThreadsState(id));\n  const [activeCommentThreadID, setActiveCommentThreadID] = useRecoilState(\n    activeCommentThreadIDAtom\n  );\n  const [shouldShowReplies, setShouldShowReplies] = useState(false);\n  const onBtnClick = useCallback(() => {\n    setShouldShowReplies(!shouldShowReplies);\n  }, [shouldShowReplies, setShouldShowReplies]);\n\n  const onClick = useCallback(() => {\n    const textNodesWithThread = Editor.nodes(editor, {\n      at: [],\n      mode: \"lowest\",\n      match: (n) => Text.isText(n) && getCommentThreadsOnTextNode(n).has(id),\n    });\n\n    let textNodeEntry = textNodesWithThread.next().value;\n    const allTextNodePaths = [];\n    while (textNodeEntry != null) {\n      allTextNodePaths.push(textNodeEntry[1]);\n      textNodeEntry = textNodesWithThread.next().value;\n    }\n    allTextNodePaths.sort((p1, p2) => Path.compare(p1, p2));\n\n    Transforms.select(editor, {\n      anchor: Editor.point(editor, allTextNodePaths[0], { edge: \"start\" }),\n      focus: Editor.point(\n        editor,\n        allTextNodePaths[allTextNodePaths.length - 1],\n        { edge: \"end\" }\n      ),\n    });\n\n    setActiveCommentThreadID(id);\n  }, [editor, id, setActiveCommentThreadID]);\n\n  if (comments.length === 0) {\n    return null;\n  }\n\n  const [firstComment, ...otherComments] = comments;\n  return (\n    <Card\n      body={true}\n      className={classNames({\n        \"comment-thread-container\": true,\n        \"is-resolved\": status === \"resolved\",\n        \"is-active\": activeCommentThreadID === id,\n      })}\n      onClick={onClick}\n    >\n      <CommentRow comment={firstComment} showConnector={false} />\n      {shouldShowReplies\n        ? otherComments.map((comment, index) => (\n            <CommentRow key={index} comment={comment} showConnector={true} />\n          ))\n        : null}\n      {comments.length > 1 ? (\n        <Button\n          className={\"show-replies-btn\"}\n          size=\"sm\"\n          variant=\"outline-primary\"\n          onClick={onBtnClick}\n        >\n          {shouldShowReplies ? \"Hide Replies\" : \"Show Replies\"}\n        </Button>\n      ) : null}\n    </Card>\n  );\n}\n","import \"./LinkEditor.css\";\n\nimport { Editor, Transforms } from \"slate\";\nimport { useCallback, useEffect, useState } from \"react\";\n\nimport Button from \"react-bootstrap/Button\";\nimport Form from \"react-bootstrap/Form\";\nimport NodePopover from \"./NodePopover\";\nimport isUrl from \"is-url\";\nimport { useEditor } from \"slate-react\";\n\nexport default function LinkEditor({ editorOffsets, selectionForLink }) {\n  const editor = useEditor();\n  const [node, path] = Editor.above(editor, {\n    at: selectionForLink,\n    match: (n) => n.type === \"link\",\n  });\n\n  const [linkURL, setLinkURL] = useState(node.url);\n\n  useEffect(() => {\n    setLinkURL(node.url);\n  }, [node]);\n\n  const onLinkURLChange = useCallback(\n    (event) => setLinkURL(event.target.value),\n    [setLinkURL]\n  );\n\n  const onApply = useCallback(\n    (event) => {\n      Transforms.setNodes(editor, { url: linkURL }, { at: path });\n    },\n    [editor, linkURL, path]\n  );\n\n  return (\n    <NodePopover\n      editorOffsets={editorOffsets}\n      node={node}\n      className={\"link-editor\"}\n    >\n      <Form.Control\n        size=\"sm\"\n        type=\"text\"\n        value={linkURL}\n        onChange={onLinkURLChange}\n      />\n      <Button\n        className={\"link-editor-btn\"}\n        size=\"sm\"\n        variant=\"primary\"\n        disabled={!isUrl(linkURL)}\n        onClick={onApply}\n      >\n        Apply\n      </Button>\n    </NodePopover>\n  );\n}\n","import {\n  commentThreadIDsState,\n  commentThreadsState,\n} from \"../utils/CommentState\";\n\nimport { useRecoilCallback } from \"recoil\";\n\nexport default function useAddCommentThreadCallback() {\n  return useRecoilCallback(\n    ({ set }) => (id, threadData) => {\n      set(commentThreadIDsState, (ids) => new Set([...Array.from(ids), id]));\n      set(commentThreadsState(id), threadData);\n    },\n    []\n  );\n}\n","import \"./Toolbar.css\";\n\nimport {\n  getActiveStyles,\n  getTextBlockStyle,\n  hasActiveLinkAtSelection,\n  toggleBlockType,\n  toggleLinkAtSelection,\n  toggleStyle,\n} from \"../utils/EditorUtils\";\nimport {\n  insertCommentThread,\n  shouldAllowNewCommentThreadAtSelection,\n} from \"../utils/EditorCommentUtils\";\n\nimport Button from \"react-bootstrap/Button\";\nimport Dropdown from \"react-bootstrap/Dropdown\";\nimport DropdownButton from \"react-bootstrap/DropdownButton\";\nimport { activeCommentThreadIDAtom } from \"../utils/CommentState\";\nimport useAddCommentThreadCallback from \"../hooks/useAddCommentThreadCallback\";\nimport { useCallback } from \"react\";\nimport { useEditor } from \"slate-react\";\nimport useImageUploadHandler from \"../hooks/useImageUploadHandler\";\nimport { useSetRecoilState } from \"recoil\";\n\nconst PARAGRAPH_STYLES = [\"h1\", \"h2\", \"h3\", \"h4\", \"paragraph\", \"multiple\"];\nconst CHARACTER_STYLES = [\"bold\", \"italic\", \"underline\", \"code\"];\n\nexport default function Toolbar({ selection, previousSelection }) {\n  const editor = useEditor();\n  const setActiveCommentThreadID = useSetRecoilState(activeCommentThreadIDAtom);\n  const addCommentThread = useAddCommentThreadCallback();\n\n  const onBlockTypeChange = useCallback(\n    (targetType) => {\n      if (targetType === \"multiple\") {\n        return;\n      }\n      toggleBlockType(editor, targetType);\n    },\n    [editor]\n  );\n\n  const onImageSelected = useImageUploadHandler(editor, previousSelection);\n\n  const onInsertComment = useCallback(() => {\n    const newCommentThreadID = insertCommentThread(editor, addCommentThread);\n    setActiveCommentThreadID(newCommentThreadID);\n  }, [editor, addCommentThread, setActiveCommentThreadID]);\n\n  const blockType = getTextBlockStyle(editor);\n\n  return (\n    <div className=\"toolbar\">\n      {/* Dropdown for paragraph styles */}\n      <DropdownButton\n        className={\"block-style-dropdown\"}\n        disabled={blockType == null || blockType === \"\"}\n        id=\"block-style\"\n        title={getLabelForBlockStyle(blockType ?? \"paragraph\")}\n        onSelect={onBlockTypeChange}\n      >\n        {PARAGRAPH_STYLES.map((blockType) => (\n          <Dropdown.Item eventKey={blockType} key={blockType}>\n            {getLabelForBlockStyle(blockType)}\n          </Dropdown.Item>\n        ))}\n      </DropdownButton>\n      {/* Buttons for character styles */}\n      {CHARACTER_STYLES.map((style) => (\n        <ToolBarStyleButton\n          key={style}\n          style={style}\n          icon={<i className={`bi ${getIconForButton(style)}`} />}\n        />\n      ))}\n      {/* Link Button */}\n      <ToolBarButton\n        isActive={hasActiveLinkAtSelection(editor)}\n        label={<i className={`bi ${getIconForButton(\"link\")}`} />}\n        onMouseDown={() => toggleLinkAtSelection(editor)}\n      />\n      {/* Image Upload Button */}\n      <ToolBarButton\n        isActive={false}\n        as={\"label\"}\n        htmlFor=\"image-upload\"\n        label={\n          <>\n            <i className={`bi ${getIconForButton(\"image\")}`} />\n            <input\n              type=\"file\"\n              id=\"image-upload\"\n              className=\"image-upload-input\"\n              accept=\"image/png, image/jpeg\"\n              onChange={onImageSelected}\n            />\n          </>\n        }\n      />\n      {/* Comment Button */}\n      <ToolBarButton\n        isActive={false}\n        disabled={!shouldAllowNewCommentThreadAtSelection(editor, selection)}\n        label={<i className={`bi ${getIconForButton(\"comment\")}`} />}\n        onMouseDown={onInsertComment}\n      />\n    </div>\n  );\n}\n\nfunction ToolBarStyleButton({ as, style, icon }) {\n  const editor = useEditor();\n  return (\n    <ToolBarButton\n      as={as}\n      onMouseDown={(event) => {\n        event.preventDefault();\n        toggleStyle(editor, style);\n      }}\n      isActive={getActiveStyles(editor).has(style)}\n      label={icon}\n    />\n  );\n}\n\nfunction ToolBarButton(props) {\n  const { label, isActive, ...otherProps } = props;\n  return (\n    <Button\n      variant=\"outline-primary\"\n      className=\"toolbar-btn\"\n      active={isActive}\n      {...otherProps}\n    >\n      {label}\n    </Button>\n  );\n}\n\nfunction getIconForButton(style) {\n  switch (style) {\n    case \"bold\":\n      return \"bi-type-bold\";\n    case \"italic\":\n      return \"bi-type-italic\";\n    case \"code\":\n      return \"bi-code-slash\";\n    case \"underline\":\n      return \"bi-type-underline\";\n    case \"image\":\n      return \"bi-file-image\";\n    case \"link\":\n      return \"bi-link-45deg\";\n    case \"comment\":\n      return \"bi-card-text\";\n    default:\n      throw new Error(`Unhandled style in getIconForButton: ${style}`);\n  }\n}\n\nfunction getLabelForBlockStyle(style) {\n  switch (style) {\n    case \"h1\":\n      return \"Heading 1\";\n    case \"h2\":\n      return \"Heading 2\";\n    case \"h3\":\n      return \"Heading 3\";\n    case \"h4\":\n      return \"Heading 4\";\n    case \"paragraph\":\n      return \"Paragraph\";\n    case \"multiple\":\n      return \"Multiple\";\n    default:\n      throw new Error(`Unhandled style in getLabelForBlockStyle: ${style}`);\n  }\n}\n","import { Editor, Transforms } from \"slate\";\n\nimport axios from \"axios\";\nimport { useCallback } from \"react\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport default function useImageUploadHandler(editor, selection) {\n  return useCallback(\n    (event) => {\n      event.preventDefault();\n      const files = event.target.files;\n      if (files.length === 0) {\n        return;\n      }\n      const file = files[0];\n      const fileName = file.name;\n      const formData = new FormData();\n      formData.append(\"photo\", file);\n\n      const id = uuidv4();\n\n      Transforms.insertNodes(\n        editor,\n        {\n          id,\n          type: \"image\",\n          caption: fileName,\n          url: null,\n          isUploading: true,\n          children: [{ text: \"\" }],\n        },\n        { at: selection, select: true }\n      );\n\n      axios\n        .post(\"/upload\", formData, {\n          headers: {\n            \"content-type\": \"multipart/form-data\",\n          },\n        })\n        .then((response) => {\n          setTimeout(() => {\n            const newImageEntry = Editor.nodes(editor, {\n              match: (n) => n.id === id,\n            });\n\n            if (newImageEntry == null) {\n              return;\n            }\n\n            Transforms.setNodes(\n              editor,\n              { isUploading: false, url: `/photos/${fileName}` },\n              { at: newImageEntry[1] }\n            );\n          }, 3000);\n        })\n        .catch((error) => {          \n          // Fire another Transform.setNodes to set an upload failed state on the image\n        });\n    },\n    [editor, selection]\n  );\n}\n","import \"./Image.css\";\n\nimport { Editor, Transforms } from \"slate\";\nimport React, { useCallback, useState } from \"react\";\nimport { useEditor, useFocused, useSelected } from \"slate-react\";\n\nimport Form from \"react-bootstrap/Form\";\nimport Spinner from \"react-bootstrap/Spinner\";\nimport classNames from \"classnames\";\nimport isHotkey from \"is-hotkey\";\n\nconst Image = ({ attributes, children, element }) => {\n  const [isEditingCaption, setEditingCaption] = useState(false);\n  const [caption, setCaption] = useState(element.caption);\n  const editor = useEditor();\n\n  const selected = useSelected();\n  const focused = useFocused();\n\n  const applyCaptionChange = useCallback(\n    (captionInput) => {\n      const imageNodeEntry = Editor.above(editor, {\n        match: (n) => n.type === \"image\",\n      });\n      if (imageNodeEntry == null) {\n        return;\n      }\n\n      if (captionInput != null) {\n        setCaption(captionInput);\n      }\n\n      Transforms.setNodes(\n        editor,\n        { caption: captionInput },\n        { at: imageNodeEntry[1] }\n      );\n    },\n    [editor, setCaption]\n  );\n\n  const onCaptionChange = useCallback(\n    (event) => {\n      setCaption(event.target.value);\n    },\n    [setCaption]\n  );\n\n  const onKeyDown = useCallback(\n    (event) => {\n      if (!isHotkey(\"enter\", event)) {\n        return;\n      }\n      event.preventDefault();\n\n      applyCaptionChange(event.target.value);\n      setEditingCaption(false);\n    },\n    [applyCaptionChange, setEditingCaption]\n  );\n\n  const onToggleCaptionEditMode = useCallback(\n    (event) => {\n      const wasEditing = isEditingCaption;\n      setEditingCaption(!isEditingCaption);\n      wasEditing && applyCaptionChange(caption);\n    },\n    [isEditingCaption, applyCaptionChange, caption]\n  );\n\n  return (    \n    <div contentEditable={false} {...attributes}>\n      <div\n        className={classNames({\n          \"image-container\": true,\n          \"is-selected\": selected && focused,\n        })}\n      >\n        {!element.isUploading && element.url != null ? (\n          <img src={String(element.url)} alt={caption} className={\"image\"} />\n        ) : (\n          <div className={\"image-upload-placeholder\"}>\n            <Spinner animation=\"border\" variant=\"dark\" />\n          </div>\n        )}\n        {isEditingCaption ? (\n          <Form.Control\n            autoFocus={true}\n            className={\"image-caption-input\"}\n            size=\"sm\"\n            type=\"text\"\n            defaultValue={caption}\n            onKeyDown={onKeyDown}\n            onChange={onCaptionChange}\n            onBlur={onToggleCaptionEditMode}\n          />\n        ) : (\n          <div\n            className={\"image-caption-read-mode\"}\n            onClick={onToggleCaptionEditMode}\n          >\n            {element.caption}\n          </div>\n        )}\n      </div>      \n      {children}\n    </div>\n  );\n};\n\nexport default Image;\n","import \"./Link.css\";\n\nexport default function Link({ element, attributes, children }) {\n  return (\n    <a href={element.url} {...attributes} className={\"link\"}>\n      {children}\n    </a>\n  );\n}\n","import \"./CommentedText.css\";\n\nimport { activeCommentThreadIDAtom } from \"../utils/CommentState\";\nimport classNames from \"classnames\";\nimport { getSmallestCommentThreadAtTextNode } from \"../utils/EditorCommentUtils\";\nimport { useEditor } from \"slate-react\";\nimport { useRecoilState } from \"recoil\";\n\nexport default function CommentedText(props) {\n  const editor = useEditor();\n  const { commentThreads, textNode, ...otherProps } = props;\n  const [activeCommentThreadID, setActiveCommentThreadID] = useRecoilState(\n    activeCommentThreadIDAtom\n  );\n\n  const onClick = () => {\n    setActiveCommentThreadID(\n      getSmallestCommentThreadAtTextNode(editor, textNode)\n    );\n  };\n\n  return (\n    <span\n      {...otherProps}\n      className={classNames({\n        comment: true,\n        \"is-active\": commentThreads.has(activeCommentThreadID),\n      })}\n      onClick={onClick}\n    >\n      {props.children}\n    </span>\n  );\n}\n","import CommentedText from \"./CommentedText\";\nimport React from \"react\";\nimport { getCommentThreadsOnTextNode } from \"../utils/EditorCommentUtils\";\n\nexport default function StyledText({ attributes, children, leaf }) {\n  if (leaf.bold) {\n    children = <strong {...attributes}>{children}</strong>;\n  }\n\n  if (leaf.code) {\n    children = <code {...attributes}>{children}</code>;\n  }\n\n  if (leaf.italic) {\n    children = <em {...attributes}>{children}</em>;\n  }\n\n  if (leaf.underline) {\n    children = <u {...attributes}>{children}</u>;\n  }\n\n  const commentThreads = getCommentThreadsOnTextNode(leaf);\n\n  if (commentThreads.size > 0) {\n    return (\n      <CommentedText\n        {...attributes}\n        commentThreads={commentThreads}\n        textNode={leaf}\n      >\n        {children}\n      </CommentedText>\n    );\n  }\n\n  return <span {...attributes}>{children}</span>;\n}\n","import { DefaultElement } from \"slate-react\";\nimport Image from \"../components/Image\";\nimport Link from \"../components/Link\";\nimport LinkEditor from \"../components/LinkEditor\";\nimport React from \"react\";\nimport StyledText from \"../components/StyledText\";\nimport isHotkey from \"is-hotkey\";\nimport { toggleStyle } from \"../utils/EditorUtils\";\n\nexport default function useEditorConfig(editor) {\n  const { isVoid } = editor;\n  editor.isVoid = (element) => {\n    return [\"image\"].includes(element.type) || isVoid(element);\n  };\n\n  editor.isInline = (element) => [\"link\"].includes(element.type);\n\n  return { renderElement, renderLeaf, KeyBindings };\n}\n\nfunction renderElement(props) {\n  const { element, children, attributes } = props;\n  switch (element.type) {\n    case \"image\":\n      return <Image {...props} />;\n    case \"paragraph\":\n      return (\n        <p {...attributes} content-editable={\"true\"}>\n          {children}\n        </p>\n      );\n    case \"h1\":\n      return (\n        <h1 {...attributes} content-editable={\"true\"}>\n          {children}\n        </h1>\n      );\n    case \"h2\":\n      return (\n        <h2 {...attributes} content-editable={\"true\"}>\n          {children}\n        </h2>\n      );\n    case \"h3\":\n      return (\n        <h3 {...attributes} content-editable={\"true\"}>\n          {children}\n        </h3>\n      );\n    case \"h4\":\n      return (\n        <h4 {...attributes} content-editable={\"true\"}>\n          {children}\n        </h4>\n      );\n    case \"link\":\n      return <Link {...props} url={element.url} />;\n    case \"link-editor\":\n      return <LinkEditor {...props} />;\n    default:\n      return <DefaultElement {...props} />;\n  }\n}\n\nfunction renderLeaf(props) {\n  return <StyledText {...props} />;\n}\n\nconst KeyBindings = {\n  onKeyDown: (editor, event) => {\n    if (isHotkey(\"mod+b\", event)) {\n      toggleStyle(editor, \"bold\");\n      return;\n    }\n    if (isHotkey(\"mod+i\", event)) {\n      toggleStyle(editor, \"italic\");\n      return;\n    }\n    if (isHotkey(\"mod+k\", event)) {\n      toggleStyle(editor, \"code\");\n      return;\n    }\n    if (isHotkey(\"mod+u\", event)) {\n      toggleStyle(editor, \"underline\");\n      return;\n    }\n  },\n};\n","import \"./Editor.css\";\n\nimport { Editable, Slate, withReact } from \"slate-react\";\nimport React, { useEffect } from \"react\";\nimport {\n  identifyLinksInTextIfAny,\n  isLinkNodeAtSelection,\n} from \"../utils/EditorUtils\";\nimport { useCallback, useMemo, useRef } from \"react\";\n\nimport Col from \"react-bootstrap/Col\";\nimport CommentThreadPopover from \"./CommentThreadPopover\";\nimport CommentsSidebar from \"./CommentsSidebar\";\nimport Container from \"react-bootstrap/Container\";\nimport LinkEditor from \"./LinkEditor\";\nimport Row from \"react-bootstrap/Row\";\nimport Toolbar from \"./Toolbar\";\nimport { activeCommentThreadIDAtom } from \"../utils/CommentState\";\nimport { createEditor } from \"slate\";\nimport { initializeStateWithAllCommentThreads } from \"../utils/EditorCommentUtils\";\nimport useAddCommentThreadCallback from \"../hooks/useAddCommentThreadCallback\";\nimport useEditorConfig from \"../hooks/useEditorConfig\";\nimport { useRecoilValue } from \"recoil\";\nimport useSelection from \"../hooks/useSelection\";\n\nexport default function Editor({ document, onChange }) {\n  const editorRef = useRef(null);\n  const editor = useMemo(() => withReact(createEditor()), []);\n  const { renderLeaf, renderElement, KeyBindings } = useEditorConfig(editor);\n\n  const onKeyDown = useCallback(\n    (event) => KeyBindings.onKeyDown(editor, event),\n    [KeyBindings, editor]\n  );\n\n  const [previousSelection, selection, setSelection] = useSelection(editor);\n  const activeCommentThreadID = useRecoilValue(activeCommentThreadIDAtom);\n  const addCommentThread = useAddCommentThreadCallback();\n\n  // we update selection here because Slate fires an onChange even on pure selection change.\n  const onChangeLocal = useCallback(\n    (doc) => {\n      onChange(doc);\n      setSelection(editor.selection);      \n      identifyLinksInTextIfAny(editor);\n    },\n    [onChange, setSelection, editor]\n  );\n\n  let selectionForLink = null;\n  if (isLinkNodeAtSelection(editor, selection)) {\n    selectionForLink = selection;\n  } else if (\n    selection == null &&\n    isLinkNodeAtSelection(editor, previousSelection)\n  ) {\n    selectionForLink = previousSelection;\n  }\n\n  const editorOffsets =\n    editorRef.current != null\n      ? {\n          x: editorRef.current.getBoundingClientRect().x,\n          y: editorRef.current.getBoundingClientRect().y,\n        }\n      : null;\n\n  useEffect(() => {\n    initializeStateWithAllCommentThreads(editor, addCommentThread);\n  }, [editor, addCommentThread]);\n\n  return (\n    <Slate editor={editor} value={document} onChange={onChangeLocal}>\n      <div className={\"editor-wrapper\"} fluid={\"true\"}>\n        <Container className={\"editor-container\"}>\n          <Row>\n            <Col>\n              <Toolbar\n                selection={selection}\n                previousSelection={previousSelection}\n              />\n            </Col>\n          </Row>\n          <Row>\n            <Col>\n              <div className=\"editor\" ref={editorRef}>\n                {selectionForLink != null ? (\n                  <LinkEditor\n                    editorOffsets={editorOffsets}\n                    selectionForLink={selectionForLink}\n                  />\n                ) : null}\n                {activeCommentThreadID != null ? (\n                  <CommentThreadPopover\n                    editorOffsets={editorOffsets}\n                    threadID={activeCommentThreadID}\n                    selection={selection ?? previousSelection}\n                  />\n                ) : null}\n                <Editable\n                  renderElement={renderElement}\n                  renderLeaf={renderLeaf}\n                  onKeyDown={onKeyDown}\n                />\n              </div>\n            </Col>\n          </Row>\n        </Container>\n        <div className={\"sidebar-wrapper\"}>\n          <CommentsSidebar />\n        </div>\n      </div>\n    </Slate>\n  );\n}\n","import { useCallback, useRef, useState } from \"react\";\n\nimport areEqual from \"deep-equal\";\n\nexport default function useSelection(editor) {\n  const [selection, setSelection] = useState(editor.selection);\n  const previousSelection = useRef(null);\n  const setSelectionOptimized = useCallback(\n    (newSelection) => {\n      if (areEqual(selection, newSelection)) {\n        return;\n      }\n      previousSelection.current = selection;\n      setSelection(newSelection);\n    },\n    [setSelection, selection]\n  );\n\n  return [previousSelection.current, selection, setSelectionOptimized];\n}\n","import { getMarkForCommentThreadID } from \"./EditorCommentUtils\";\nimport { v4 as uuid } from \"uuid\";\n\nconst overlappingCommentThreadID = uuid();\n\nconst ExampleDocument = [\n  {\n    type: \"h1\",\n    children: [{ text: \"Document Title (Heading H1)\" }],\n  },\n  {\n    type: \"h2\",\n    children: [{ text: \"Subtitle (Heading H2)\" }],\n  },\n  {\n    type: \"paragraph\",\n    children: [\n      {\n        text: \"Text 1\",\n        [getMarkForCommentThreadID(uuid())]: true,\n      },\n      {\n        text: \"Text 2\",\n        [getMarkForCommentThreadID(overlappingCommentThreadID)]: true,\n      },\n      {\n        text: \"Text 3\",\n        bold: true,\n        [getMarkForCommentThreadID(overlappingCommentThreadID)]: true,\n        [getMarkForCommentThreadID(uuid())]: true,\n      },\n      {\n        text: \"Text 4\",\n        bold: true,\n        [getMarkForCommentThreadID(uuid())]: true,\n      },\n      {\n        text:\n          \" is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum\",\n      }\n    ]\n  }\n];\n\nexport default ExampleDocument;\n","import \"./App.css\";\nimport { RecoilRoot, useRecoilSnapshot } from \"recoil\";\nimport { useEffect, useState } from \"react\";\n\nimport Editor from \"./components/Editor\";\nimport ExampleDocument from \"./utils/ExampleDocument\";\nimport React from \"react\";\n\nfunction App() {\n  const [document, updateDocument] = useState(ExampleDocument);\n\n  return (\n    <>\n      <div className=\"App\">\n        <RecoilRoot>\n          <Editor document={document} onChange={updateDocument} />\n          <DebugObserver />\n        </RecoilRoot>\n      </div>\n    </>\n  );\n}\n\nfunction DebugObserver(): React.Node {\n  const snapshot = useRecoilSnapshot();\n  useEffect(() => {\n    console.debug(\"The following atoms were modified:\");\n    for (const node of snapshot.getNodes_UNSTABLE({ isModified: true })) {\n      console.debug(node.key, snapshot.getLoadable(node));\n    }\n  }, [snapshot]);\n\n  return null;\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import \"./index.css\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport App from \"./App\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}